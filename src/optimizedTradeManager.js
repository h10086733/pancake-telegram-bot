const { ethers } = require('ethers');
const config = require('./config');
const fs = require('fs');
const path = require('path');

class OptimizedTradeManager {
  constructor({ routerVersion = 'v2' } = {}) {
    console.log('üîß ÂàùÂßãÂåñ OptimizedTradeManager...');
    this.provider = new ethers.JsonRpcProvider(config.BSC_RPC_URL);
    this.wallet = new ethers.Wallet(config.PRIVATE_KEY, this.provider);

    // V2 Router
    this.routerV2Address = config.PANCAKESWAP_ROUTER_V2_ADDRESS;
    this.routerV2ABI = [
      "function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)",
      "function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable",
      "function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external"
    ];
    this.routerV2 = new ethers.Contract(this.routerV2Address, this.routerV2ABI, this.wallet);

    // V3 Router
    this.routerV3Address = config.PANCAKESWAP_ROUTER_V3_ADDRESS;
    this.routerV3ABI = [
      // V3 ABI Âè™ÂåÖÂê´Ê†∏ÂøÉÂäüËÉΩ
      "function exactInputSingle((address,address,uint24,address,uint256,uint256,uint160)) external payable returns (uint256)",
      "function quoteExactInputSingle(address,address,uint24,uint256) external view returns (uint256)"
    ];
    this.routerV3 = new ethers.Contract(this.routerV3Address, this.routerV3ABI, this.wallet);

    // Ë∑ØÁî±Âô®ÈÄâÊã©
    this.routerVersion = routerVersion;
    this.router = this.routerVersion === 'v3' ? this.routerV3 : this.routerV2;
    this.routerAddress = this.routerVersion === 'v3' ? this.routerV3Address : this.routerV2Address;
    console.log(`üìã ‰ΩøÁî®Ë∑ØÁî±Âô®: ${this.routerAddress} (${this.routerVersion.toUpperCase()})`);
    
    // ERC20 ABI (Á≤æÁÆÄÁâà)
    this.erc20ABI = [
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
      "function balanceOf(address) view returns (uint256)",
      "function approve(address spender, uint256 amount) returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)"
    ];
    
    // Settings
    this.settings = {
      slippage: 10, // 10%
      gasPrice: 0.1, // 0.1 Gwei
      gasLimit: 300000
    };
    
    // File path for storing traded tokens
    this.tradedTokensFile = path.join(__dirname, '..', 'traded-tokens.json');
    this.ensureTradedTokensFile();
    
    console.log('‚úÖ OptimizedTradeManager ÂàùÂßãÂåñÂÆåÊàê');
  }

  /**
   * Á°Æ‰øù‰∫§Êòì‰ª£Â∏ÅÊñá‰ª∂Â≠òÂú®
   */
  ensureTradedTokensFile() {
    if (!fs.existsSync(this.tradedTokensFile)) {
      fs.writeFileSync(this.tradedTokensFile, JSON.stringify({ tokens: [] }, null, 2));
    }
  }

  /**
   * Ëé∑ÂèñÂ∑≤‰∫§ÊòìÁöÑ‰ª£Â∏ÅÂàóË°®
   */
  getTradedTokens() {
    try {
      const data = fs.readFileSync(this.tradedTokensFile, 'utf8');
      return JSON.parse(data).tokens || [];
    } catch (error) {
      return [];
    }
  }

  /**
   * Ê∑ªÂä†‰ª£Â∏ÅÂà∞Â∑≤‰∫§ÊòìÂàóË°®
   */
  addTradedToken(tokenAddress) {
    try {
      const tokens = this.getTradedTokens();
      if (!tokens.includes(tokenAddress.toLowerCase())) {
        tokens.push(tokenAddress.toLowerCase());
        fs.writeFileSync(this.tradedTokensFile, JSON.stringify({ tokens }, null, 2));
      }
    } catch (error) {
      console.error('Error adding traded token:', error);
    }
  }

  /**
   * ÁßªÈô§Â∑≤‰∫§Êòì‰ª£Â∏Å
   */
  removeTradedToken(tokenAddress) {
    try {
      const tokens = this.getTradedTokens();
      const idx = tokens.indexOf(tokenAddress.toLowerCase());
      if (idx !== -1) {
        tokens.splice(idx, 1);
        fs.writeFileSync(this.tradedTokensFile, JSON.stringify({ tokens }, null, 2));
      }
    } catch (error) {
      console.error('Error removing traded token:', error);
    }
  }

  /**
   * Ëé∑ÂèñBNB‰ª∑Ê†º
   */
  async getBNBPrice() {
    try {
      const response = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BNBUSDT');
      const data = await response.json();
      return parseFloat(data.price) || 600;
    } catch (error) {
      return 600;
    }
  }

  /**
   * È™åËØÅ‰ª£Â∏ÅÂú∞ÂùÄ
   */
  async isValidTokenAddress(tokenAddress) {
    try {
      if (!ethers.isAddress(tokenAddress)) {
        return false;
      }
      const tokenContract = new ethers.Contract(tokenAddress, this.erc20ABI, this.provider);
      await tokenContract.symbol();
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Ëé∑ÂèñÈí±ÂåÖ‰ΩôÈ¢ù
   */
  async getWalletBalance() {
    try {
      const balance = await this.provider.getBalance(this.wallet.address);
      return {
        success: true,
        balance: ethers.formatEther(balance),
        address: this.wallet.address
      };
    } catch (error) {
      return { success: false, error: 'Ëé∑ÂèñÈí±ÂåÖ‰ΩôÈ¢ùÂ§±Ë¥•' };
    }
  }

  /**
   * Ëé∑Âèñ‰ª£Â∏Å‰ΩôÈ¢ù
   */
  async getTokenBalance(tokenAddress) {
    try {
      const tokenContract = new ethers.Contract(tokenAddress, this.erc20ABI, this.provider);
      const [balance, decimals] = await Promise.all([
        tokenContract.balanceOf(this.wallet.address),
        tokenContract.decimals()
      ]);
      return ethers.formatUnits(balance, decimals);
    } catch (error) {
      return '0';
    }
  }

  /**
   * Ëé∑Âèñ‰ª£Â∏Å‰ª∑Ê†º
   */
  async getTokenPrice(tokenAddress) {
    try {
      const tokenContract = new ethers.Contract(tokenAddress, this.erc20ABI, this.provider);
      const [decimals, symbol] = await Promise.all([
        tokenContract.decimals(),
        tokenContract.symbol()
      ]);
      
      const bnbAmount = ethers.parseEther('1');
      const path = [config.WBNB_ADDRESS, tokenAddress];
      
      const amounts = await this.router.getAmountsOut(bnbAmount, path);
      const tokensOut = amounts[1];
      
      const tokensPerBNB = parseFloat(ethers.formatUnits(tokensOut, decimals));
      const priceInBNB = 1 / tokensPerBNB;
      
      const bnbPriceUSD = await this.getBNBPrice();
      const priceInUSD = priceInBNB * bnbPriceUSD;
      
      return {
        success: true,
        symbol: symbol,
        priceInBNB: priceInBNB.toFixed(18),
        priceInUSD: priceInUSD.toFixed(6),
        liquidity: 'V2Ê±†Â≠ê',
        price: priceInBNB.toFixed(18)
      };
    } catch (error) {
      return { success: false, error: 'Êó†Ê≥ïËé∑Âèñ‰ª∑Ê†º‰ø°ÊÅØ' };
    }
  }

  // V3‰ª∑Ê†ºÊü•ËØ¢
  async getTokenPriceV3(tokenAddress, fee = 2500) {
    try {
      const bnbAmount = ethers.parseEther('1');
      const quoted = await this.routerV3.quoteExactInputSingle(
        config.WBNB_ADDRESS,
        tokenAddress,
        fee,
        bnbAmount
      );
      const tokenContract = new ethers.Contract(tokenAddress, this.erc20ABI, this.provider);
      const decimals = await tokenContract.decimals();
      const tokensOut = quoted;
      const tokensPerBNB = parseFloat(ethers.formatUnits(tokensOut, decimals));
      const priceInBNB = 1 / tokensPerBNB;
      const bnbPriceUSD = await this.getBNBPrice();
      const priceInUSD = priceInBNB * bnbPriceUSD;
      return {
        success: true,
        priceInBNB: priceInBNB.toFixed(18),
        priceInUSD: priceInUSD.toFixed(6),
        liquidity: 'V3Ê±†Â≠ê',
        price: priceInBNB.toFixed(18)
      };
    } catch (error) {
      return { success: false, error: 'Êó†Ê≥ïËé∑ÂèñV3‰ª∑Ê†º‰ø°ÊÅØ' };
    }
  }

  /**
   * Ëé∑Âèñ‰ª£Â∏ÅÊåÅ‰ªì
   */
  async getTokenHoldings() {
    try {
      const tradedTokens = this.getTradedTokens();
      const holdings = [];
      let totalValueUSD = 0;

      // Ê∑ªÂä†BNB‰ΩôÈ¢ù
      const bnbBalance = await this.provider.getBalance(this.wallet.address);
      const bnbAmount = parseFloat(ethers.formatEther(bnbBalance));
      const bnbPriceUSD = await this.getBNBPrice();
      const bnbValueUSD = bnbAmount * bnbPriceUSD;
      
      holdings.push({
        symbol: 'BNB',
        balance: bnbAmount.toFixed(6),
        priceUSD: bnbPriceUSD.toFixed(2),
        valueUSD: bnbValueUSD.toFixed(2),
        isNative: true,
        address: null
      });
      
      totalValueUSD += bnbValueUSD;
      let foundTokens = 1;

      // Ê£ÄÊü•‰ª£Â∏Å
      for (const tokenAddress of tradedTokens) {
        try {
          const balance = await this.getTokenBalance(tokenAddress);
          const balanceNum = parseFloat(balance);
          
          if (balanceNum > 0) {
            const tokenContract = new ethers.Contract(tokenAddress, this.erc20ABI, this.provider);
            const symbol = await tokenContract.symbol();
            
            const priceInfo = await this.getTokenPrice(tokenAddress);
            let priceUSD = 0;
            let valueUSD = 0;
            
            if (priceInfo.success) {
              priceUSD = parseFloat(priceInfo.priceInUSD);
              valueUSD = balanceNum * priceUSD;
              totalValueUSD += valueUSD;
            }
            
            holdings.push({
              symbol: symbol,
              balance: balanceNum.toFixed(6),
              priceUSD: priceUSD.toFixed(6),
              valueUSD: valueUSD.toFixed(2),
              isNative: false,
              address: tokenAddress
            });
            
            foundTokens++;
          }
        } catch (error) {
          console.error(`Ê£ÄÊü•‰ª£Â∏ÅÂ§±Ë¥•:`, error);
        }
      }

      return {
        success: true,
        tokens: holdings, // ‰øÆÊ≠£‰∏∫tokensÂ≠óÊÆµÔºåÂÖºÂÆπÊµãËØïËÑöÊú¨
        totalValueUSD: totalValueUSD.toFixed(2),
        scannedTokens: tradedTokens.length,
        foundTokens: foundTokens,
        fromTradingHistory: true
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * Êô∫ËÉΩ‰π∞ÂÖ•
   */
  async smartBuy(tokenAddress, bnbAmount) {
    try {
      console.log(`üõí ‰π∞ÂÖ•: ${tokenAddress}, ${bnbAmount} BNB`);
      
      const isValid = await this.isValidTokenAddress(tokenAddress);
      if (!isValid) {
        return { success: false, error: 'Êó†ÊïàÁöÑ‰ª£Â∏ÅÂú∞ÂùÄ' };
      }

      const tokenContract = new ethers.Contract(tokenAddress, this.erc20ABI, this.provider);
      const [symbol, decimals] = await Promise.all([
        tokenContract.symbol(),
        tokenContract.decimals()
      ]);
      
      const amountIn = ethers.parseEther(bnbAmount.toString());
      const path = [config.WBNB_ADDRESS, tokenAddress];
      
      const amounts = await this.router.getAmountsOut(amountIn, path);
      const amountOutMin = amounts[1] * BigInt(100 - this.settings.slippage) / BigInt(100);
      
      const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
      
      const tx = await this.router.swapExactETHForTokensSupportingFeeOnTransferTokens(
        amountOutMin,
        path,
        this.wallet.address,
        deadline,
        {
          value: amountIn,
          gasPrice: ethers.parseUnits(this.settings.gasPrice.toString(), 'gwei'),
          gasLimit: this.settings.gasLimit
        }
      );
      
      const receipt = await tx.wait();
      
      if (receipt.status === 1) {
        this.addTradedToken(tokenAddress);
        
        return {
          success: true,
          txHash: tx.hash,
          message: `ÊàêÂäü‰π∞ÂÖ• ${symbol}`,
          details: {
            amountIn: bnbAmount,
            expectedTokens: ethers.formatUnits(amounts[1], decimals),
            slippage: this.settings.slippage,
            gasUsed: receipt.gasUsed.toString()
          }
        };
      } else {
        return { success: false, error: '‰∫§ÊòìÂ§±Ë¥•' };
      }
    } catch (error) {
      console.error('‰π∞ÂÖ•Â§±Ë¥•:', error);
      return { success: false, error: `‰π∞ÂÖ•Â§±Ë¥•: ${error.reason || error.message}` };
    }
  }

  // V3‰π∞ÂÖ•
  async smartBuyV3(tokenAddress, bnbAmount, fee = 2500) {
    // ËøôÈáåÂè™ÊòØÊñπÊ≥ïÊ°ÜÊû∂ÔºåÂÖ∑‰ΩìÂèÇÊï∞ÂíåÊªëÁÇπ‰øùÊä§ÂèØÊ†πÊçÆÂÆûÈôÖÈúÄÊ±ÇÂÆåÂñÑ
    try {
      console.log(`üõí V3‰π∞ÂÖ•: ${tokenAddress}, ${bnbAmount} BNB`);
      
      const isValid = await this.isValidTokenAddress(tokenAddress);
      if (!isValid) {
        return { success: false, error: 'Êó†ÊïàÁöÑ‰ª£Â∏ÅÂú∞ÂùÄ' };
      }

      const tokenContract = new ethers.Contract(tokenAddress, this.erc20ABI, this.provider);
      const [symbol, decimals] = await Promise.all([
        tokenContract.symbol(),
        tokenContract.decimals()
      ]);
      
      const amountIn = ethers.parseEther(bnbAmount.toString());
      const path = [config.WBNB_ADDRESS, tokenAddress];
      
      const quoted = await this.routerV3.quoteExactInputSingle(
        config.WBNB_ADDRESS,
        tokenAddress,
        fee,
        amountIn
      );
      
      const amountOutMin = quoted * BigInt(100 - this.settings.slippage) / BigInt(100);
      
      const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
      
      const tx = await this.routerV3.exactInputSingle({
        tokenIn: config.WBNB_ADDRESS,
        tokenOut: tokenAddress,
        fee: fee,
        recipient: this.wallet.address,
        deadline: deadline,
        amountIn: amountIn,
        amountOutMinimum: amountOutMin,
        sqrtPriceLimit: 0
      });
      
      const receipt = await tx.wait();
      
      if (receipt.status === 1) {
        this.addTradedToken(tokenAddress);
        
        return {
          success: true,
          txHash: tx.hash,
          message: `ÊàêÂäüV3‰π∞ÂÖ• ${symbol}`,
          details: {
            amountIn: bnbAmount,
            expectedTokens: ethers.formatUnits(quoted, decimals),
            slippage: this.settings.slippage,
            gasUsed: receipt.gasUsed.toString()
          }
        };
      } else {
        return { success: false, error: '‰∫§ÊòìÂ§±Ë¥•' };
      }
    } catch (error) {
      console.error('V3‰π∞ÂÖ•Â§±Ë¥•:', error);
      return { success: false, error: `‰π∞ÂÖ•Â§±Ë¥•: ${error.reason || error.message}` };
    }
  }

  /**
   * Êô∫ËÉΩÂçñÂá∫
   */
  async smartSell(tokenAddress, tokenAmount) {
    try {
      console.log(`üí∏ ÂçñÂá∫: ${tokenAddress}, ${tokenAmount}`);
      
      const isValid = await this.isValidTokenAddress(tokenAddress);
      if (!isValid) {
        return { success: false, error: 'Êó†ÊïàÁöÑ‰ª£Â∏ÅÂú∞ÂùÄ' };
      }

      const tokenContract = new ethers.Contract(tokenAddress, this.erc20ABI, this.provider);
      const [symbol, decimals] = await Promise.all([
        tokenContract.symbol(),
        tokenContract.decimals()
      ]);
      
      const balance = await this.getTokenBalance(tokenAddress);
      const balanceNum = parseFloat(balance);
      const sellAmount = parseFloat(tokenAmount);
      
      if (balanceNum < sellAmount) {
        return { 
          success: false, 
          error: `‰ΩôÈ¢ù‰∏çË∂≥: ${balanceNum.toFixed(6)} ${symbol}` 
        };
      }
      
      const amountIn = ethers.parseUnits(tokenAmount.toString(), decimals);
      
      // Ê£ÄÊü•ÊéàÊùÉ
      const allowance = await tokenContract.allowance(this.wallet.address, this.routerAddress);
      
      if (allowance < amountIn) {
        console.log('ÊéàÊùÉ‰ª£Â∏Å...');
        const approveTx = await tokenContract.approve(this.routerAddress, ethers.MaxUint256);
        await approveTx.wait();
      }
      
      const path = [tokenAddress, config.WBNB_ADDRESS];
      const amounts = await this.router.getAmountsOut(amountIn, path);
      const amountOutMin = amounts[1] * BigInt(100 - this.settings.slippage) / BigInt(100);
      
      const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
      
      const tx = await this.router.swapExactTokensForETHSupportingFeeOnTransferTokens(
        amountIn,
        amountOutMin,
        path,
        this.wallet.address,
        deadline,
        {
          gasPrice: ethers.parseUnits(this.settings.gasPrice.toString(), 'gwei'),
          gasLimit: this.settings.gasLimit
        }
      );
      
      const receipt = await tx.wait();
      
      if (receipt.status === 1) {
        // ÂçñÂá∫ÊàêÂäüÂêéÊ£ÄÊü•‰ΩôÈ¢ùÔºåËã•‰∏∫0ÂàôÁßªÈô§
        const remain = await this.getTokenBalance(tokenAddress);
        if (parseFloat(remain) === 0) {
          this.removeTradedToken(tokenAddress);
        }
        return {
          success: true,
          txHash: tx.hash,
          message: `ÊàêÂäüÂçñÂá∫ ${tokenAmount} ${symbol}`,
          details: {
            amountIn: tokenAmount,
            expectedBNB: ethers.formatEther(amounts[1]),
            slippage: this.settings.slippage,
            gasUsed: receipt.gasUsed.toString()
          }
        };
      } else {
        return { success: false, error: '‰∫§ÊòìÂ§±Ë¥•' };
      }
    } catch (error) {
      console.error('ÂçñÂá∫Â§±Ë¥•:', error);
      return { success: false, error: `ÂçñÂá∫Â§±Ë¥•: ${error.reason || error.message}` };
    }
  }

  // V3ÂçñÂá∫
  async smartSellV3(tokenAddress, tokenAmount, fee = 2500) {
    // ËøôÈáåÂè™ÊòØÊñπÊ≥ïÊ°ÜÊû∂ÔºåÂÖ∑‰ΩìÂèÇÊï∞ÂíåÊªëÁÇπ‰øùÊä§ÂèØÊ†πÊçÆÂÆûÈôÖÈúÄÊ±ÇÂÆåÂñÑ
    try {
      console.log(`üí∏ V3ÂçñÂá∫: ${tokenAddress}, ${tokenAmount}`);
      
      const isValid = await this.isValidTokenAddress(tokenAddress);
      if (!isValid) {
        return { success: false, error: 'Êó†ÊïàÁöÑ‰ª£Â∏ÅÂú∞ÂùÄ' };
      }

      const tokenContract = new ethers.Contract(tokenAddress, this.erc20ABI, this.provider);
      const [symbol, decimals] = await Promise.all([
        tokenContract.symbol(),
        tokenContract.decimals()
      ]);
      
      const balance = await this.getTokenBalance(tokenAddress);
      const balanceNum = parseFloat(balance);
      const sellAmount = parseFloat(tokenAmount);
      
      if (balanceNum < sellAmount) {
        return { 
          success: false, 
          error: `‰ΩôÈ¢ù‰∏çË∂≥: ${balanceNum.toFixed(6)} ${symbol}` 
        };
      }
      
      const amountIn = ethers.parseUnits(tokenAmount.toString(), decimals);
      
      // Ê£ÄÊü•ÊéàÊùÉ
      const allowance = await tokenContract.allowance(this.wallet.address, this.routerAddress);
      
      if (allowance < amountIn) {
        console.log('ÊéàÊùÉ‰ª£Â∏Å...');
        const approveTx = await tokenContract.approve(this.routerAddress, ethers.MaxUint256);
        await approveTx.wait();
      }
      
      const quoted = await this.routerV3.quoteExactInputSingle(
        tokenAddress,
        config.WBNB_ADDRESS,
        fee,
        amountIn
      );
      
      const amountOutMin = quoted * BigInt(100 - this.settings.slippage) / BigInt(100);
      
      const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
      
      const tx = await this.routerV3.exactInputSingle({
        tokenIn: tokenAddress,
        tokenOut: config.WBNB_ADDRESS,
        fee: fee,
        recipient: this.wallet.address,
        deadline: deadline,
        amountIn: amountIn,
        amountOutMinimum: amountOutMin,
        sqrtPriceLimit: 0
      });
      
      const receipt = await tx.wait();
      
      if (receipt.status === 1) {
        // V3ÂçñÂá∫ÊàêÂäüÂêéÊ£ÄÊü•‰ΩôÈ¢ùÔºåËã•‰∏∫0ÂàôÁßªÈô§
        const remain = await this.getTokenBalance(tokenAddress);
        if (parseFloat(remain) === 0) {
          this.removeTradedToken(tokenAddress);
        }
        return {
          success: true,
          txHash: tx.hash,
          message: `ÊàêÂäüV3ÂçñÂá∫ ${tokenAmount} ${symbol}`,
          details: {
            amountIn: tokenAmount,
            expectedBNB: ethers.formatEther(quoted),
            slippage: this.settings.slippage,
            gasUsed: receipt.gasUsed.toString()
          }
        };
      } else {
        return { success: false, error: '‰∫§ÊòìÂ§±Ë¥•' };
      }
    } catch (error) {
      console.error('V3ÂçñÂá∫Â§±Ë¥•:', error);
      return { success: false, error: `ÂçñÂá∫Â§±Ë¥•: ${error.reason || error.message}` };
    }
  }

  /**
   * Ê∑ªÂä†‰ª£Â∏ÅÂà∞ÁõëÊéßÂàóË°®
   */
  async addToken(tokenAddress) {
    try {
      const isValid = await this.isValidTokenAddress(tokenAddress);
      if (!isValid) {
        return { success: false, error: 'Êó†ÊïàÁöÑ‰ª£Â∏ÅÂú∞ÂùÄ' };
      }

      this.addTradedToken(tokenAddress);
      
      const tokenContract = new ethers.Contract(tokenAddress, this.erc20ABI, this.provider);
      const symbol = await tokenContract.symbol();

      return {
        success: true,
        message: `Â∑≤Ê∑ªÂä†‰ª£Â∏Å: ${symbol}`,
        token: { address: tokenAddress, symbol }
      };
    } catch (error) {
      return { success: false, error: `Ê∑ªÂä†Â§±Ë¥•: ${error.message}` };
    }
  }
}

module.exports = OptimizedTradeManager;
